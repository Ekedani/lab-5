//Вероятнее всего, релизить мы будем R*, так как он более эффективный, но сложно быть не должно
//Ссылка на эту дичь https://habr.com/ru/post/224965/

//Узел дерева
template <class T>
struct Node{
    //Я еще смутно представляю структуру узлов этого дерева, но что-то придумаем
    T data;
};

//Само дерево
template <class T>
class rTree {
private:
    //Корень дерева
    Node<T> *root;

    //Каждый узел дерева имеет минимальное (minCount) и максимальное (maxCount) количество объектов.
    //Для корректной работы алгоритмов построения дерева нужно, что бы 2 <= minCount <= maxCount / 2

    //Минимальное и максимальное количество элементов в узле
    int minCount;
    int maxCount;

    //Авторы R*-дерева в своей статье утверждают,
    // что наилучшая производительность данной структуры достигается при minCount = maxCount * 40%.

public:
    //TODO: Алгоритм выбора поддерева (chooseSubtree)

    //TODO: Алгоритм деления узла (splitNode)

    //TODO: Собственно сама вставка (insertObject)

    //TODO: Поиск объектов в заданом радиусе (findObjectsInArea)

    //TODO: Так же, если я не ошибаюсь, R* требует регулировки некоторых параметров при splitNode
};
